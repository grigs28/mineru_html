<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MinerU PDFè½¬æ¢å·¥å…·</title>
    <link rel="stylesheet" href="static/styles.css">
    <!-- æ·»åŠ marked.jsç”¨äºæ›´å¥½çš„Markdownæ¸²æŸ“ -->
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
    <!-- æ·»åŠ KaTeXç”¨äºæ•°å­¦å…¬å¼æ¸²æŸ“ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <!-- æ·»åŠ JSZipç”¨äºZIPæ–‡ä»¶å¤„ç† -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>MinerU PDFè½¬æ¢å·¥å…·</h1>
            <p>æ™ºèƒ½PDFæ–‡æ¡£è§£æä¸è½¬æ¢å¹³å° <span class="version-text" onclick="app.showChangelog()" title="ç‚¹å‡»æŸ¥çœ‹æ›´æ–°æ—¥å¿—">v0.1.1</span></p>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">ğŸ“</div>
                    <div class="upload-text">æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</div>
                    <div class="upload-hint">æ”¯æŒPDFå’Œå›¾ç‰‡æ–‡ä»¶ï¼Œå¯åŒæ—¶ä¸Šä¼ å¤šä¸ªæ–‡ä»¶</div>
                    <input type="file" id="fileInput" multiple accept=".pdf,.png,.jpg,.jpeg,.bmp,.tiff" style="display: none;">
                </div>


                <div class="form-group">
                    <label for="maxPages">æœ€å¤§è½¬æ¢é¡µæ•°</label>
                    <div class="slider-container">
                        <input type="range" id="maxPages" class="slider" min="1" max="1000" value="500">
                        <span id="maxPagesValue">500</span>
                    </div>
                </div>

                <div class="form-group">
                    <label for="backend">åç«¯é€‰æ‹©</label>
                    <select id="backend" class="form-control">
                        <option value="pipeline">Pipeline</option>
                        <option value="vlm-transformers">VLM Transformers</option>
                        <option value="vlm-sglang-client">VLM SgLang Client</option>
                        <option value="vlm-sglang-engine" selected>VLM SgLang Engine</option>
                    </select>
                </div>

                <div class="form-group" id="serverUrlGroup" style="display: none;">
                    <label for="serverUrl">æœåŠ¡å™¨URL</label>
                    <input type="text" id="serverUrl" class="form-control" value="http://localhost:30000" placeholder="http://localhost:30000">
                </div>

                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="formulaEnable" checked>
                        <label for="formulaEnable">å¯ç”¨å…¬å¼è¯†åˆ«</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="tableEnable" checked>
                        <label for="tableEnable">å¯ç”¨è¡¨æ ¼è¯†åˆ«</label>
                    </div>
                </div>

                <div class="form-group" id="ocrOptions" style="display: none;">
                    <label for="language">è¯­è¨€</label>
                    <select id="language" class="form-control">
                        <option value="ch">ä¸­æ–‡</option>
                        <option value="en">è‹±æ–‡</option>
                        <option value="latin">æ‹‰ä¸è¯­ç³»</option>
                        <option value="arabic">é˜¿æ‹‰ä¼¯è¯­ç³»</option>
                        <option value="east_slavic">ä¸œæ–¯æ‹‰å¤«è¯­ç³»</option>
                        <option value="cyrillic">è¥¿é‡Œå°”è¯­ç³»</option>
                        <option value="devanagari">å¤©åŸæ–‡è¯­ç³»</option>
                    </select>
                    <div class="checkbox-item" style="margin-top: 10px;">
                        <input type="checkbox" id="isOcr">
                        <label for="isOcr">å¼ºåˆ¶å¯ç”¨OCR</label>
                    </div>
                </div>


                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>æ­£åœ¨å¤„ç†æ–‡ä»¶ï¼Œè¯·ç¨å€™...</p>
                </div>


                <!-- PDFé¢„è§ˆåŒºåŸŸ -->
                <div class="pdf-preview-section" id="pdfPreviewSection">
                    <h3>ğŸ“„ PDFé¢„è§ˆ</h3>
                    <div class="pdf-preview-container" id="pdfPreviewContainer">
                        <div class="pdf-preview-placeholder">
                            <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“„</div>
                            <p>PDFé¢„è§ˆ</p>
                            <p style="font-size: 14px; color: #999;">ä¸Šä¼ PDFæ–‡ä»¶åå°†æ˜¾ç¤ºé¢„è§ˆ</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <!-- ç»Ÿä¸€æ–‡ä»¶çŠ¶æ€å¡ç‰‡åŒºåŸŸ -->
                <div class="file-status-cards" id="fileStatusCards">
                    <div class="cards-header">
                        <h3>ğŸ“ æ–‡ä»¶åˆ—è¡¨</h3>
                        <div class="cards-actions">
                            <button class="btn-convert" id="convertBtn" title="å¼€å§‹è½¬æ¢">
                                <span class="icon">ğŸš€</span>
                                <span class="btn-text">å¼€å§‹è½¬æ¢</span>
                            </button>
                            <button class="btn-clear" id="clearBtn" title="æ¸…ç©º">
                                <span class="icon">ğŸ—‘ï¸</span>
                                <span class="btn-text">æ¸…ç©º</span>
                            </button>
                            <button class="btn-download-all" onclick="app.downloadAllResults()" title="å…¨éƒ¨ä¸‹è½½">
                                <span class="icon">ğŸ“¥</span>
                                <span class="btn-text">å…¨éƒ¨ä¸‹è½½</span>
                            </button>
                        </div>
                    </div>
                    <div class="cards-container" id="cardsContainer">
                        <div class="empty-state">
                            <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“‹</div>
                            <p>æš‚æ— æ–‡ä»¶</p>
                            <p style="font-size: 14px; color: #999;">ä¸Šä¼ æ–‡ä»¶åå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</p>
                        </div>
                    </div>
                </div>

                <div class="tabs">
                    <div class="tab active" data-tab="markdown-rendering">Markdown rendering</div>
                    <div class="tab" data-tab="markdown-text">Markdown text</div>
                    <div class="tab" data-tab="examples">è¾“å‡ºæ–‡ä»¶</div>
                </div>

                <div class="tab-content active" id="markdown-renderingTab">
                    <div class="markdown-container">
                        <div class="markdown-header">
                            <h3>Markdown rendering</h3>
                            <button class="btn-copy" id="copyMarkdownBtn" onclick="app.copyMarkdown()" title="å¤åˆ¶Markdownå†…å®¹">
                                ğŸ“‹ å¤åˆ¶
                            </button>
                        </div>
                    <div class="markdown-preview" id="markdownPreview">
                        <p style="text-align: center; color: #666; margin-top: 100px;">
                                è¯·ä¸Šä¼ æ–‡ä»¶å¹¶å¼€å§‹è½¬æ¢ä»¥æŸ¥çœ‹Markdownæ¸²æŸ“
                        </p>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="markdown-textTab">
                    <div class="markdown-container">
                        <div class="markdown-header">
                            <h3>Markdown text</h3>
                            <button class="btn-copy" id="copyTextBtn" onclick="app.copyText()" title="å¤åˆ¶æ–‡æœ¬å†…å®¹">
                                ğŸ“‹ å¤åˆ¶
                            </button>
                        </div>
                    <div class="markdown-text" id="markdownText">
                        <p style="text-align: center; color: #666; margin-top: 100px;">
                                è¯·ä¸Šä¼ æ–‡ä»¶å¹¶å¼€å§‹è½¬æ¢ä»¥æŸ¥çœ‹Markdownæ–‡æœ¬
                        </p>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="examplesTab">
                    <div class="examples-section">
                        <div class="examples-header">
                            <h3>è¾“å‡ºç›®å½•æ–‡ä»¶</h3>
                            <div class="examples-actions">
                                <button class="btn-refresh" id="refreshExamples">ğŸ”„ åˆ·æ–°</button>
                                <button class="btn-select-all" id="selectAllExamples">â˜‘ï¸ å…¨é€‰</button>
                                <button class="btn-delete-selected" id="deleteSelected">ğŸ—‘ï¸ åˆ é™¤</button>
                            </div>
                        </div>
                        <div class="examples-list" id="examplesList">
                            <p style="text-align: center; color: #666; padding: 20px;">
                                æ­£åœ¨åŠ è½½æ–‡ä»¶åˆ—è¡¨...
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- CHANGELOGæ¨¡æ€æ¡† -->
    <div id="changelogModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ğŸ“‹ æ›´æ–°æ—¥å¿—</h2>
                <span class="close" onclick="app.closeChangelog()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="changelogContent">
                    <div class="loading">æ­£åœ¨åŠ è½½æ›´æ–°æ—¥å¿—...</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        class MinerUApp {
            constructor() {
                this.uploadedFiles = [];
                this.processingFiles = new Set();
                this.results = new Map();
                this.isProcessing = false;
                this.currentProcessingIndex = -1;
                this.loadFromStorage();
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.updateSliderValue();
                this.updateBackendOptions();
                this.refreshVersion();
                this.syncFileListFromServer();
                this.loadExamples();
                this.updateFileList();
            }

            async syncFileListFromServer() {
                // ä»æœåŠ¡ç«¯è·å–å…±äº«æ–‡ä»¶åˆ—è¡¨ï¼Œä¸æœ¬åœ°åˆå¹¶ï¼ˆæœåŠ¡ç«¯ä¸ºä¸»ï¼‰
                try {
                    const res = await fetch('/api/file_list');
                    if (!res.ok) return;
                    const serverFiles = await res.json();
                    if (Array.isArray(serverFiles)) {
                        // ä»¥æœåŠ¡ç«¯ä¸ºä¸»ï¼Œæ›¿æ¢ä¸Šä¼ åˆ—è¡¨ï¼ˆä»…çŠ¶æ€/å…ƒä¿¡æ¯ï¼ŒFileå¯¹è±¡ä¸ºç©ºï¼‰
                        const merged = serverFiles.map(f => ({
                            file: null,
                            name: f.name,
                            size: f.size || 0,
                            status: f.status || 'completed',
                            uploadTime: f.uploadTime || null,
                            startTime: f.startTime || null,
                            endTime: f.endTime || null,
                            processingTime: f.processingTime || null
                        }));
                        this.uploadedFiles = merged;
                        this.updateFileList();
                        this.saveToStorage();
                    }
                } catch (e) {
                    console.warn('syncFileListFromServer failed', e);
                }
            }

            async syncFileListToServer() {
                // å°†å½“å‰æ–‡ä»¶åˆ—è¡¨æ¨é€åˆ°æœåŠ¡ç«¯å…±äº«
                try {
                    const payload = {
                        files: this.uploadedFiles.map(f => ({
                            name: f.name,
                            size: f.size || 0,
                            status: f.status || 'pending',
                            uploadTime: f.uploadTime || null,
                            startTime: f.startTime || null,
                            endTime: f.endTime || null,
                            processingTime: f.processingTime || null
                        }))
                    };
                    await fetch('/api/file_list', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                } catch (e) {
                    console.warn('syncFileListToServer failed', e);
                }
            }

            async refreshVersion() {
                try {
                    const res = await fetch('/api/version');
                    if (!res.ok) return;
                    const data = await res.json();
                    const el = document.querySelector('.version-text');
                    if (el && data.version) {
                        el.textContent = data.version;
                    }
                } catch (e) {
                    console.warn('è·å–ç‰ˆæœ¬å¤±è´¥', e);
                }
            }

            // æŒä¹…åŒ–å­˜å‚¨æ–¹æ³•
            saveToStorage() {
                const data = {
                    uploadedFiles: this.uploadedFiles.map(file => ({
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        lastModified: file.lastModified,
                        status: file.status || 'pending',
                        startTime: file.startTime || null,
                        endTime: file.endTime || null,
                        processingTime: file.processingTime || null
                    })),
                    results: Array.from(this.results.entries())
                };
                localStorage.setItem('mineru_files', JSON.stringify(data));
            }

            loadFromStorage() {
                try {
                    const data = localStorage.getItem('mineru_files');
                    if (data) {
                        const parsed = JSON.parse(data);
                        // æ¢å¤æ–‡ä»¶åˆ—è¡¨ï¼ˆä¸åŒ…å«Fileå¯¹è±¡ï¼Œéœ€è¦é‡æ–°åˆ›å»ºï¼‰
                        this.uploadedFiles = parsed.uploadedFiles || [];
                        // æ¢å¤ç»“æœ
                        if (parsed.results) {
                            this.results = new Map(parsed.results);
                        }
                        
                        // æ¢å¤æ•°æ®åæ›´æ–°UI
                        this.updateFileList();
                        
                        // å¦‚æœæœ‰æ–‡ä»¶ï¼Œæ˜¾ç¤ºç¬¬ä¸€ä¸ªæ–‡ä»¶çš„é¢„è§ˆ
                        if (this.uploadedFiles.length > 0) {
                            this.showFirstFilePreview();
                        }
                    }
                } catch (error) {
                    console.error('åŠ è½½å­˜å‚¨æ•°æ®å¤±è´¥:', error);
                    this.uploadedFiles = [];
                    this.results = new Map();
                }
            }

            // è·å–åŒ—äº¬æ—¶åŒºæ—¶é—´
            getBeijingTime() {
                return new Date().toLocaleString('zh-CN', {
                    timeZone: 'Asia/Shanghai',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            }

            // è®¡ç®—å¤„ç†æ—¶é•¿
            calculateProcessingTime(startTime, endTime) {
                if (!startTime || !endTime) return null;
                const start = new Date(startTime);
                const end = new Date(endTime);
                const diffMs = end - start;
                const minutes = Math.floor(diffMs / 60000);
                const seconds = Math.floor((diffMs % 60000) / 1000);
                return `${minutes}åˆ†${seconds}ç§’`;
            }

            setupEventListeners() {
                // æ–‡ä»¶ä¸Šä¼ 
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));

                // æ»‘å—
                document.getElementById('maxPages').addEventListener('input', this.updateSliderValue.bind(this));

                // åç«¯é€‰æ‹©
                document.getElementById('backend').addEventListener('change', this.updateBackendOptions.bind(this));

                // æŒ‰é’®
                document.getElementById('convertBtn').addEventListener('click', this.startConversion.bind(this));
                document.getElementById('clearBtn').addEventListener('click', this.clearAll.bind(this));

                // æ ‡ç­¾é¡µ
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', this.switchTab.bind(this));
                });

                // è¾“å‡ºæ–‡ä»¶æ“ä½œ
                document.getElementById('refreshExamples').addEventListener('click', this.loadExamples.bind(this));
                document.getElementById('selectAllExamples').addEventListener('click', this.selectAllExamples.bind(this));
                document.getElementById('deleteSelected').addEventListener('click', this.deleteSelectedExamples.bind(this));
            }

            handleDragOver(e) {
                e.preventDefault();
                e.currentTarget.classList.add('dragover');
            }

            handleDragLeave(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                this.addFiles(files);
            }

            handleFileSelect(e) {
                const files = Array.from(e.target.files);
                this.addFiles(files);
            }

            addFiles(files) {
                const validFiles = files.filter(file => {
                    const ext = file.name.toLowerCase().split('.').pop();
                    return ['pdf', 'png', 'jpg', 'jpeg', 'bmp', 'tiff'].includes(ext);
                });

                validFiles.forEach(file => {
                    if (!this.uploadedFiles.find(f => f.name === file.name && f.size === file.size)) {
                        this.uploadedFiles.push({
                            file: file,
                            name: file.name,
                            size: file.size,
                            status: 'pending',
                            uploadTime: new Date(),
                            startTime: null,
                            endTime: null,
                            processingTime: null
                        });
                    }
                });

                this.updateFileList();
                this.saveToStorage();
                this.syncFileListToServer();
                
                // æ‰¹é‡ä¸Šä¼ åæ˜¾ç¤ºç¬¬ä¸€ä¸ªæ–‡ä»¶çš„é¢„è§ˆ
                if (validFiles.length > 0) {
                    // æ˜¾ç¤ºç¬¬ä¸€ä¸ªæ–‡ä»¶çš„é¢„è§ˆ
                    this.showFirstFilePreview();
                }
            }

            updateFileList() {
                // ç›´æ¥æ›´æ–°æ–‡ä»¶çŠ¶æ€å¡ç‰‡
                this.updateFileStatusCards();
            }

            updateFileStatusCards() {
                const fileStatusCards = document.getElementById('fileStatusCards');
                const cardsContainer = document.getElementById('cardsContainer');
                
                // æ–‡ä»¶çŠ¶æ€åŒºåŸŸå§‹ç»ˆæ˜¾ç¤º
                    fileStatusCards.style.display = 'block';
                
                // å¦‚æœæœ‰æ–‡ä»¶ï¼Œæ˜¾ç¤ºæ–‡ä»¶å¡ç‰‡
                if (this.uploadedFiles.length > 0 || this.results.size > 0) {
                    cardsContainer.innerHTML = '';

                    // æ˜¾ç¤ºä¸Šä¼ çš„æ–‡ä»¶ï¼ˆåŒ…æ‹¬å·²ä¸Šä¼ å’Œæ­£åœ¨å¤„ç†çš„ï¼‰
                    this.uploadedFiles.forEach((fileData, index) => {
                        const fileCard = this.createFileCard(fileData, index);
                        cardsContainer.appendChild(fileCard);
                    });

                } else {
                    // æ˜¾ç¤ºç©ºçŠ¶æ€
                    cardsContainer.innerHTML = `
                        <div class="empty-state">
                            <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“‹</div>
                            <p>æš‚æ— æ–‡ä»¶</p>
                            <p style="font-size: 14px; color: #999;">ä¸Šä¼ æ–‡ä»¶åå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</p>
                        </div>
                    `;
                }
            }

            createFileCard(fileData, index) {
                const card = document.createElement('div');
                card.className = 'file-card';
                
                const fileIcon = this.getFileIcon(fileData.name);
                const statusBadge = this.getStatusBadge(fileData.status);
                const progressBar = this.getProgressBar(fileData.status);
                const actions = this.getFileActions(fileData, index);
                
                // æ„å»ºç®€åŒ–çš„æ—¶é—´ä¿¡æ¯
                let timeInfo = '';
                if (fileData.status === 'processing' && fileData.startTime) {
                    timeInfo = `å¼€å§‹: ${fileData.startTime} | çŠ¶æ€: å¤„ç†ä¸­`;
                } else if (fileData.status === 'completed') {
                    timeInfo = `å¼€å§‹: ${fileData.startTime || 'æœªçŸ¥'} | ç»“æŸ: ${fileData.endTime || 'æœªçŸ¥'} | è€—æ—¶: ${fileData.processingTime || 'æœªçŸ¥'}`;
                } else if (fileData.status === 'error') {
                    timeInfo = `å¼€å§‹: ${fileData.startTime || 'æœªçŸ¥'} | å¤±è´¥: ${fileData.endTime || 'æœªçŸ¥'} | è€—æ—¶: ${fileData.processingTime || 'æœªçŸ¥'}`;
                } else {
                    timeInfo = 'çŠ¶æ€: å¾…å¤„ç†';
                }
                
                const detailInfo = `
                    <div class="file-detail">
                        <div class="detail-item-single">
                            <span class="detail-value">${timeInfo}</span>
                        </div>
                    </div>
                `;
                
                card.innerHTML = `
                    <div class="file-card-header">
                        <div class="file-info">
                            <span class="file-icon">${fileIcon}</span>
                            <span class="file-name" title="${fileData.name}">${fileData.name}</span>
                        </div>
                        <div class="status-badge ${fileData.status}">${statusBadge}</div>
                    </div>
                    <div class="file-card-body">
                        ${progressBar}
                        ${detailInfo}
                    </div>
                    <div class="file-card-footer">
                        <span class="file-size">${this.formatFileSize(fileData.size)}</span>
                        <div class="footer-actions">
                            ${fileData.status === 'completed' && this.results.has(fileData.name) 
                                ? `<button class="btn-card btn-download" onclick="app.downloadResult('${fileData.name}')">ğŸ“¥ ä¸‹è½½</button>`
                                : `<button class="btn-card btn-download" disabled>ğŸ“¥ ä¸‹è½½</button>`
                            }
                            ${actions}
                        </div>
                    </div>
                `;
                
                return card;
            }


            getFileIcon(filename) {
                const ext = filename.toLowerCase().split('.').pop();
                const iconMap = {
                    'pdf': 'ğŸ“„',
                    'png': 'ğŸ–¼ï¸',
                    'jpg': 'ğŸ–¼ï¸',
                    'jpeg': 'ğŸ–¼ï¸',
                    'gif': 'ğŸ–¼ï¸',
                    'webp': 'ğŸ–¼ï¸',
                    'md': 'ğŸ“',
                    'txt': 'ğŸ“„',
                    'zip': 'ğŸ“¦'
                };
                return iconMap[ext] || 'ğŸ“';
            }

            getStatusBadge(status) {
                const statusMap = {
                    'pending': 'â³ å¾…å¤„ç†',
                    'processing': 'âš™ï¸ å¤„ç†ä¸­',
                    'completed': 'âœ… æˆåŠŸ',
                    'error': 'âŒ å¤±è´¥'
                };
                return statusMap[status] || 'â“ æœªçŸ¥';
            }

            getProgressBar(status) {
                if (status === 'processing') {
                    return `
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 60%; animation: pulse 2s infinite;"></div>
                        </div>
                    `;
                } else if (status === 'completed') {
                    return `
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 100%;"></div>
                        </div>
                    `;
                } else if (status === 'error') {
                    return `
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 100%; background: #dc3545;"></div>
                        </div>
                    `;
                }
                return '';
            }

            getFileActions(fileData, index) {
                const viewBtn = fileData.status === 'completed' && this.results.has(fileData.name)
                    ? `<button class="btn-card btn-view" onclick="app.viewResult('${fileData.name}')">ğŸ‘ï¸ æŸ¥çœ‹</button>`
                    : `<button class="btn-card btn-view" disabled>ğŸ‘ï¸ æŸ¥çœ‹</button>`;
                
                const deleteBtn = `<button class="btn-card btn-delete" onclick="app.removeFile(${index})">ğŸ—‘ï¸ åˆ é™¤</button>`;
                
                return viewBtn + deleteBtn;
            }

            formatTime(date) {
                if (!date) return '';
                const now = new Date();
                const diff = now - date;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);
                
                if (days > 0) return `${days}å¤©å‰`;
                if (hours > 0) return `${hours}å°æ—¶å‰`;
                if (minutes > 0) return `${minutes}åˆ†é’Ÿå‰`;
                return 'åˆšåˆš';
            }
            
            getTimeInfo(fileData) {
                switch (fileData.status) {
                    case 'pending':
                        return `ğŸ“¤ å¾…å¤„ç†`;
                    case 'processing':
                        if (fileData.startTime) {
                            return `âš™ï¸ å¤„ç†ä¸­ (å¼€å§‹: ${fileData.startTime})`;
                        }
                        return 'âš™ï¸ å¤„ç†ä¸­';
                    case 'completed':
                        if (fileData.processingTime) {
                            return `âœ… å®Œæˆ (è€—æ—¶: ${fileData.processingTime})`;
                        }
                        return 'âœ… å®Œæˆ';
                    case 'error':
                        if (fileData.processingTime) {
                            return `âŒ å¤±è´¥ (è€—æ—¶: ${fileData.processingTime})`;
                        }
                        return 'âŒ å¤±è´¥';
                    default:
                        return 'ğŸ“¤ å¾…å¤„ç†';
                }
            }
            
            formatDuration(milliseconds) {
                const seconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                
                if (hours > 0) {
                    return `${hours}å°æ—¶${minutes % 60}åˆ†é’Ÿ`;
                } else if (minutes > 0) {
                    return `${minutes}åˆ†${seconds % 60}ç§’`;
                } else {
                    return `${seconds}ç§’`;
                }
            }

            getStatusText(status) {
                const statusMap = {
                    'pending': 'å¾…å¤„ç†',
                    'processing': 'å¤„ç†ä¸­',
                    'completed': 'è½¬æ¢æˆåŠŸ',
                    'error': 'è½¬æ¢å¤±è´¥'
                };
                return statusMap[status] || status;
            }

            removeFile(index) {
                this.uploadedFiles.splice(index, 1);
                this.updateFileList();
            }

            updateSliderValue() {
                const slider = document.getElementById('maxPages');
                const value = document.getElementById('maxPagesValue');
                value.textContent = slider.value;
            }

            updateBackendOptions() {
                const backend = document.getElementById('backend').value;
                const serverUrlGroup = document.getElementById('serverUrlGroup');
                const ocrOptions = document.getElementById('ocrOptions');

                if (backend === 'vlm-sglang-client') {
                    serverUrlGroup.style.display = 'block';
                    ocrOptions.style.display = 'none';
                } else if (backend === 'pipeline') {
                    serverUrlGroup.style.display = 'none';
                    ocrOptions.style.display = 'block';
                } else if (backend === 'vlm-sglang-engine' || backend === 'vlm-transformers') {
                    serverUrlGroup.style.display = 'none';
                    ocrOptions.style.display = 'none';
                } else {
                    serverUrlGroup.style.display = 'none';
                    ocrOptions.style.display = 'none';
                }
            }

            async startConversion() {
                if (this.uploadedFiles.length === 0) {
                    alert('è¯·å…ˆä¸Šä¼ æ–‡ä»¶');
                    return;
                }

                if (this.isProcessing) {
                    alert('è½¬æ¢æ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆ');
                    return;
                }

                this.isProcessing = true;
                const convertBtn = document.getElementById('convertBtn');
                convertBtn.disabled = true;
                convertBtn.innerHTML = '<span class="icon">â³</span><span class="btn-text">è½¬æ¢ä¸­</span>';

                try {
                    // é€ä¸€å¤„ç†æ–‡ä»¶
                    for (let i = 0; i < this.uploadedFiles.length; i++) {
                        const fileData = this.uploadedFiles[i];
                        
                        // åªå¤„ç†å¾…å¤„ç†çš„æ–‡ä»¶
                        if (fileData.status === 'pending') {
                            this.currentProcessingIndex = i;
                            
                            // æ›´æ–°çŠ¶æ€ä¸ºå¤„ç†ä¸­
                            fileData.status = 'processing';
                            fileData.startTime = this.getBeijingTime();
                            this.updateFileList();
                            this.saveToStorage();
                            this.syncFileListToServer();
                            
                            // æ˜¾ç¤ºå½“å‰å¤„ç†æ–‡ä»¶çš„é¢„è§ˆ
                            this.showProcessingPreview(fileData);
                            
                            // å¤„ç†æ–‡ä»¶
                            await this.processFile(fileData);
                            
                            // æ›´æ–°çŠ¶æ€ä¸ºå®Œæˆ
                            fileData.status = 'completed';
                            fileData.endTime = this.getBeijingTime();
                            fileData.processingTime = this.calculateProcessingTime(fileData.startTime, fileData.endTime);
                            this.updateFileList();
                            this.saveToStorage();
                            this.syncFileListToServer();
                            
                            // æ˜¾ç¤ºå®Œæˆé¢„è§ˆ
                            this.showCompletedPreview(fileData);
                        }
                    }
                    
                    // æ‰€æœ‰æ–‡ä»¶å¤„ç†å®Œæˆ
                    alert('æ‰€æœ‰æ–‡ä»¶è½¬æ¢å®Œæˆï¼æ‚¨å¯ä»¥å…³é—­æµè§ˆå™¨ï¼Œè½¬æ¢ç»“æœå·²ä¿å­˜ã€‚');
                    
                } catch (error) {
                    console.error('è½¬æ¢è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
                    alert('è½¬æ¢è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: ' + error.message);
                } finally {
                    this.isProcessing = false;
                    this.currentProcessingIndex = -1;
                    convertBtn.disabled = false;
                    convertBtn.innerHTML = '<span class="icon">ğŸš€</span><span class="btn-text">å¼€å§‹è½¬æ¢</span>';
                }
            }

            async processFile(fileData) {
                try {
                    // æ£€æŸ¥æ–‡ä»¶ç±»å‹ï¼Œå¦‚æœä¸æ˜¯PDFï¼Œå…ˆè½¬æ¢ä¸ºPDF
                    let fileToProcess = fileData.file;
                    const fileName = fileData.name.toLowerCase();
                    const isPdf = fileName.endsWith('.pdf');
                    
                    if (!isPdf) {
                        // éPDFæ–‡ä»¶ï¼Œéœ€è¦å…ˆè½¬æ¢ä¸ºPDF
                        console.log(`è½¬æ¢éPDFæ–‡ä»¶: ${fileData.name}`);
                        // è¿™é‡Œéœ€è¦è°ƒç”¨åç«¯çš„to_pdfæ¥å£
                        const convertResponse = await fetch('/convert_to_pdf', {
                            method: 'POST',
                            body: fileData.file
                        });
                        
                        if (convertResponse.ok) {
                            const pdfBlob = await convertResponse.blob();
                            fileToProcess = new File([pdfBlob], fileData.name.replace(/\.[^/.]+$/, '.pdf'), { type: 'application/pdf' });
                        } else {
                            throw new Error('æ–‡ä»¶è½¬æ¢ä¸ºPDFå¤±è´¥');
                        }
                    }
                    
                    const formData = new FormData();
                    // files must be Blob/File
                    formData.append('files', fileToProcess);
                    // Always send strings for non-file fields
                    formData.append('output_dir', './output');
                    const lang = (document.getElementById('language') && document.getElementById('language').value) || 'ch';
                    formData.append('lang_list', String(lang));
                    formData.append('backend', String(document.getElementById('backend').value));
                    const isOcrEnabled = !!(document.getElementById('isOcr') && document.getElementById('isOcr').checked);
                    formData.append('parse_method', isOcrEnabled ? 'ocr' : 'auto');
                    formData.append('formula_enable', String(!!document.getElementById('formulaEnable').checked));
                    formData.append('table_enable', String(!!document.getElementById('tableEnable').checked));
                    const serverUrlVal = (document.getElementById('serverUrl') && document.getElementById('serverUrl').value) || '';
                    if (serverUrlVal) {
                        formData.append('server_url', String(serverUrlVal));
                    }
                    formData.append('return_md', String(true));
                    formData.append('return_images', String(true));
                    formData.append('response_format_zip', String(false));
                    formData.append('start_page_id', String(0));
                    const endPage = Math.max(0, parseInt(document.getElementById('maxPages').value, 10) - 1);
                    formData.append('end_page_id', String(endPage));

                    const response = await fetch('/file_parse', {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        // æ£€æŸ¥å“åº”ç±»å‹
                        const contentType = response.headers.get('content-type');
                        
                        if (contentType && contentType.includes('application/json')) {
                            // å¦‚æœæ˜¯JSONå“åº”ï¼Œç›´æ¥è§£æ
                            const result = await response.json();
                            this.handleJsonResponse(fileData, result);
                        } else {
                            // å¦‚æœæ˜¯ZIPæ–‡ä»¶ï¼Œç›´æ¥å­˜å‚¨blob
                            const blob = await response.blob();
                            this.handleZipResponse(fileData, blob);
                        }

                        fileData.status = 'completed';
                        fileData.endTime = new Date();
                        if (fileData.startTime) {
                            fileData.processingTime = fileData.endTime - fileData.startTime;
                        }
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (error) {
                    console.error(`å¤„ç†æ–‡ä»¶ ${fileData.name} æ—¶å‡ºé”™:`, error);
                    fileData.status = 'error';
                    fileData.endTime = new Date();
                    if (fileData.startTime) {
                        fileData.processingTime = fileData.endTime - fileData.startTime;
                    }
                }
            }
            
            async handleJsonResponse(fileData, result) {
                // ç›´æ¥ä½¿ç”¨åç«¯è¿”å›çš„ç»“æœï¼ˆä¸gradio_app.py.sampleå®Œå…¨ä¸€è‡´ï¼‰
                const mdContent = result.md_content || '';
                const txtContent = result.txt_content || '';
                const zipPath = result.archive_zip_path || '';
                const pdfPath = result.new_pdf_path || '';
                
                // ä½¿ç”¨åç«¯ç”Ÿæˆçš„æ–‡ä»¶å
                const fileName = result.file_name || fileData.name.replace(/\.[^/.]+$/, '');
                
                this.results.set(fileData.name, {
                    mdContent: mdContent,
                    txtContent: txtContent,
                    zipPath: zipPath,
                    pdfPath: pdfPath,
                    filename: fileName + '.md',
                    originalName: fileData.name,
                    type: 'json'
                });
                
                // ç«‹å³æ˜¾ç¤ºç»“æœ
                this.showMarkdownResult(fileData.name, mdContent, txtContent);
            }
            
            handleZipResponse(fileData, blob) {
                // ç›´æ¥å­˜å‚¨åç«¯è¿”å›çš„ZIPæ–‡ä»¶ï¼ˆä¸gradio_app.py.sampleå®Œå…¨ä¸€è‡´ï¼‰
                const timestamp = this.getCurrentTimestamp();
                const baseName = this.safeStem(fileData.name);
                const fileName = `${baseName}_${timestamp}`;
                
                this.results.set(fileData.name, {
                    blob: blob,
                    filename: fileName + '.zip',
                    originalName: fileData.name,
                    type: 'zip'
                });
                
                // æ˜¾ç¤ºå¤„ç†å®Œæˆæ¶ˆæ¯
                this.showMarkdownResult(fileData.name, 
                    '## è½¬æ¢å®Œæˆ\n\næ–‡ä»¶å·²æˆåŠŸè½¬æ¢ï¼Œè¯·ç‚¹å‡»ä¸‹è½½æŒ‰é’®è·å–å®Œæ•´çš„è½¬æ¢ç»“æœã€‚', 
                    'è½¬æ¢å®Œæˆ\n\næ–‡ä»¶å·²æˆåŠŸè½¬æ¢ï¼Œè¯·ç‚¹å‡»ä¸‹è½½æŒ‰é’®è·å–å®Œæ•´çš„è½¬æ¢ç»“æœã€‚'
                );
            }
            
            
            // ç”Ÿæˆå½“å‰æ—¶é—´æˆ³ï¼ˆæ ¼å¼ï¼šyymmdd_HHMMSSï¼‰
            getCurrentTimestamp() {
                const now = new Date();
                const year = now.getFullYear().toString().slice(-2);
                const month = (now.getMonth() + 1).toString().padStart(2, '0');
                const day = now.getDate().toString().padStart(2, '0');
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const seconds = now.getSeconds().toString().padStart(2, '0');
                return `${year}${month}${day}_${hours}${minutes}${seconds}`;
            }
            
            // å®‰å…¨æ–‡ä»¶åå¤„ç†ï¼ˆä¿ç•™ä¸­æ–‡ã€å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œç‚¹ï¼‰
            safeStem(filename) {
                const nameWithoutExt = filename.replace(/\.[^/.]+$/, '');
                return nameWithoutExt.replace(/[^\w.\u4e00-\u9fff]/g, '_');
            }
            
            
            async showMarkdownResult(filename, mdContent = null, txtContent = null) {
                // åˆ‡æ¢åˆ°Markdown renderingæ ‡ç­¾é¡µ
                this.switchToTab('markdown-rendering');
                
                // å¦‚æœæ²¡æœ‰æä¾›å†…å®¹ï¼Œä»å·²å­˜å‚¨çš„ç»“æœä¸­è·å–
                if (!mdContent || !txtContent) {
                    const result = this.results.get(filename);
                    if (result && result.mdContent && result.txtContent) {
                        mdContent = result.mdContent;
                        txtContent = result.txtContent;
                    } else {
                        // å¦‚æœæ²¡æœ‰å­˜å‚¨çš„å†…å®¹ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
                        mdContent = '## æç¤º\n\næš‚æ— Markdownå†…å®¹ï¼Œè¯·å…ˆè½¬æ¢æ–‡ä»¶ã€‚';
                        txtContent = 'æš‚æ— Markdownå†…å®¹ï¼Œè¯·å…ˆè½¬æ¢æ–‡ä»¶ã€‚';
                    }
                }
                
                // æ˜¾ç¤ºæ¸²æŸ“åçš„Markdown
                document.getElementById('markdownPreview').innerHTML = 
                    `<div class="markdown-content">${this.markdownToHtml(mdContent)}</div>`;
                
                // æ˜¾ç¤ºåŸå§‹Markdownæ–‡æœ¬
                document.getElementById('markdownText').textContent = txtContent;
                
                // å¦‚æœæ˜¯PDFæ–‡ä»¶ï¼Œæ˜¾ç¤ºPDFé¢„è§ˆ
                if (filename.toLowerCase().endsWith('.pdf')) {
                    const fileData = this.uploadedFiles.find(f => f.name === filename);
                    if (fileData && fileData.file instanceof Blob) {
                        this.showPdfPreview(fileData.file);
                    } else {
                        // åˆ·æ–°åè‡ªåŠ¨å‘åç«¯æŸ¥è¯¢åŒ¹é…çš„PDF
                        try {
                            const resp = await fetch(`/output/find_pdf?q=${encodeURIComponent(filename)}`);
                            if (resp.ok) {
                                const data = await resp.json();
                                if (data && data.path) {
                                    // ä½¿ç”¨ encodeURI ä¿ç•™è·¯å¾„ä¸­çš„æ–œæ ï¼Œä»…å¯¹ä¸­æ–‡ç­‰å­—ç¬¦ç¼–ç 
                                    this.showPdfPreviewByUrl(`/output/raw/${encodeURI(data.path)}`);
                                } else {
                                    this.clearPdfPreview();
                                }
                            } else {
                                this.clearPdfPreview();
                            }
                        } catch (_) {
                            this.clearPdfPreview();
                        }
                    }
                } else {
                    // æ¸…ç©ºPDFé¢„è§ˆåŒºåŸŸ
                    this.clearPdfPreview();
                }
            }


            async downloadResult(filename) {
                // ä»¥blobä¸‹è½½å¹¶ä¿å­˜ä¸º.zipï¼Œé¿å…æµè§ˆå™¨ç›´æ¥æ‰“å¼€URLå¯¼è‡´å±•ç¤ºézipå
                try {
                    const res = await fetch(`/download_file/${encodeURIComponent(filename)}`);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const blob = await res.blob();
                    const blobUrl = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = blobUrl;
                    a.download = `${this.safeStem(filename)}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(blobUrl);
                } catch (err) {
                    console.error('ä¸‹è½½å¤±è´¥:', err);
                    alert('ä¸‹è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
                }
            }

            async downloadAllResults() {
                // æ”¶é›†æœ¬æ¬¡ä»»åŠ¡ä¸­â€œå·²å®Œæˆâ€çš„æ–‡ä»¶å
                const completed = this.uploadedFiles
                    .filter(f => f.status === 'completed')
                    .map(f => f.name);
                if (completed.length === 0) {
                    alert('æš‚æ— å·²å®Œæˆçš„æ–‡ä»¶å¯æ‰“åŒ…');
                    return;
                }
                try {
                    const res = await fetch('/download_all', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ files: completed })
                    });
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    const ts = this.getCurrentTimestamp();
                    a.href = url;
                    a.download = `all_results_${ts}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (e) {
                    console.error('å…¨éƒ¨ä¸‹è½½å¤±è´¥:', e);
                    alert('å…¨éƒ¨ä¸‹è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
                }
            }
            

            async viewResult(filename) {
                // ç›´æ¥è°ƒç”¨showMarkdownResultï¼Œå®ƒä¼šä»åç«¯APIè·å–æœ€æ–°çš„Markdownå†…å®¹
                await this.showMarkdownResult(filename);
            }

            showProcessingPreview(fileData) {
                // åˆ‡æ¢åˆ°Markdown renderingæ ‡ç­¾é¡µ
                this.switchToTab('markdown-rendering');
                
                // æ˜¾ç¤ºå¤„ç†ä¸­çš„é¢„è§ˆ
                const processingContent = `# æ­£åœ¨å¤„ç†æ–‡ä»¶

## ğŸ“„ ${fileData.name}

**çŠ¶æ€**: âš™ï¸ å¤„ç†ä¸­  
**è¿›åº¦**: æ­£åœ¨è½¬æ¢ä¸­ï¼Œè¯·ç¨å€™...

---

### å¤„ç†ä¿¡æ¯
- **æ–‡ä»¶å**: ${fileData.name}
- **æ–‡ä»¶å¤§å°**: ${this.formatFileSize(fileData.size)}
- **å¼€å§‹æ—¶é—´**: ${new Date().toLocaleString()}
- **å¤„ç†çŠ¶æ€**: æ­£åœ¨OCRè¯†åˆ«å’Œæ ¼å¼è½¬æ¢

> ğŸ’¡ **æç¤º**: å¤„ç†æ—¶é—´å–å†³äºæ–‡ä»¶å¤§å°å’Œå¤æ‚åº¦ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚

---

<div style="text-align: center; margin: 20px 0;">
    <div style="display: inline-block; padding: 10px 20px; background: #f0f8ff; border: 1px solid #4a90e2; border-radius: 8px;">
        <div style="font-size: 24px; margin-bottom: 10px;">âš™ï¸</div>
        <div style="color: #4a90e2; font-weight: bold;">æ­£åœ¨å¤„ç†ä¸­...</div>
                        </div>
                    </div>`;

                document.getElementById('markdownPreview').innerHTML = 
                    `<div class="markdown-content">${this.markdownToHtml(processingContent)}</div>`;
                document.getElementById('markdownText').textContent = processingContent;
                
                // å¦‚æœæ˜¯PDFæ–‡ä»¶ï¼Œæ˜¾ç¤ºPDFé¢„è§ˆ
                if (fileData.name.toLowerCase().endsWith('.pdf')) {
                    this.showPdfPreview(fileData.file);
                } else {
                    // æ¸…ç©ºPDFé¢„è§ˆåŒºåŸŸ
                    this.clearPdfPreview();
                }
            }

            async showCompletedPreview(fileData) {
                // ç›´æ¥è°ƒç”¨showMarkdownResultï¼Œå®ƒä¼šä»åç«¯APIè·å–æœ€æ–°çš„Markdownå†…å®¹
                await this.showMarkdownResult(fileData.name);
            }

            showFirstFilePreview() {
                if (this.uploadedFiles.length > 0) {
                    const firstFile = this.uploadedFiles[0];
                    // åˆ‡æ¢åˆ°Markdown renderingæ ‡ç­¾é¡µ
                    this.switchToTab('markdown-rendering');
                    
                    // æ˜¾ç¤ºç¬¬ä¸€ä¸ªæ–‡ä»¶çš„é¢„è§ˆ
                    const filePreviewContent = `# ğŸ“ æ–‡ä»¶å·²ä¸Šä¼ 

## ${this.getFileIcon(firstFile.name)} ${firstFile.name}

**æ–‡ä»¶ä¿¡æ¯**:
- **æ–‡ä»¶å**: ${firstFile.name}
- **æ–‡ä»¶å¤§å°**: ${this.formatFileSize(firstFile.size)}
- **ä¸Šä¼ æ—¶é—´**: ${this.formatTime(firstFile.uploadTime)}
- **çŠ¶æ€**: ${this.getStatusBadge(firstFile.status)}
- **æ—¶é—´ä¿¡æ¯**: ${this.getTimeInfo(firstFile)}

---

### ä¸‹ä¸€æ­¥æ“ä½œ

> ğŸš€ **å‡†å¤‡è½¬æ¢**: æ–‡ä»¶å·²æˆåŠŸä¸Šä¼ ï¼Œç‚¹å‡»å³ä¾§çš„"**å¼€å§‹è½¬æ¢**"æŒ‰é’®å¼€å§‹å¤„ç†æ–‡ä»¶ã€‚

**è½¬æ¢é€‰é¡¹**:
- âœ… å…¬å¼è¯†åˆ«: å·²å¯ç”¨
- âœ… è¡¨æ ¼è¯†åˆ«: å·²å¯ç”¨
- ğŸ“„ æœ€å¤§é¡µæ•°: ${document.getElementById('maxPages').value}é¡µ
- ğŸ”§ åç«¯: ${document.getElementById('backend').value}

---

<div style="text-align: center; margin: 20px 0;">
    <div style="display: inline-block; padding: 15px 25px; background: #e8f5e8; border: 1px solid #4caf50; border-radius: 8px;">
        <div style="font-size: 20px; margin-bottom: 8px;">ğŸ“‹</div>
        <div style="color: #2e7d32; font-weight: bold;">æ–‡ä»¶å‡†å¤‡å°±ç»ª</div>
        <div style="color: #666; font-size: 14px; margin-top: 5px;">ç‚¹å‡»å¼€å§‹è½¬æ¢æŒ‰é’®å¼€å§‹å¤„ç†</div>
    </div>
                        </div>`;

                    document.getElementById('markdownPreview').innerHTML = 
                        `<div class="markdown-content">${this.markdownToHtml(filePreviewContent)}</div>`;
                    document.getElementById('markdownText').textContent = filePreviewContent;
                    
                    // å¦‚æœæ˜¯PDFæ–‡ä»¶ï¼Œæ˜¾ç¤ºPDFé¢„è§ˆ
                    if (firstFile.name.toLowerCase().endsWith('.pdf') && firstFile.file instanceof Blob) {
                        this.showPdfPreview(firstFile.file);
                    } else {
                        // æ¸…ç©ºPDFé¢„è§ˆåŒºåŸŸ
                        this.clearPdfPreview();
                    }
                }
            }

            clearAll() {
                if (this.isProcessing) {
                    alert('è½¬æ¢è¿›è¡Œä¸­ï¼Œæ— æ³•æ¸…ç©ºæ–‡ä»¶åˆ—è¡¨');
                    return;
                }
                
                if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ–‡ä»¶å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                    return;
                }
                
                this.uploadedFiles = [];
                this.processingFiles.clear();
                this.results.clear();
                
                // æ¸…ç†URLå¯¹è±¡
                this.results.forEach(result => {
                    if (result.url) {
                        URL.revokeObjectURL(result.url);
                    }
                });
                
                this.updateFileList();
                this.saveToStorage();
                this.syncFileListToServer();
                
                // æ¸…ç©ºé¢„è§ˆ
                const defaultContent = `# ğŸ“„ MinerU PDFè½¬æ¢å·¥å…·

## æ¬¢è¿ä½¿ç”¨æ™ºèƒ½PDFæ–‡æ¡£è§£æä¸è½¬æ¢å¹³å°

### åŠŸèƒ½ç‰¹ç‚¹
- ğŸ“„ **PDFè½¬æ¢**: æ”¯æŒPDFæ–‡æ¡£è½¬æ¢ä¸ºMarkdownæ ¼å¼
- ğŸ–¼ï¸ **å›¾ç‰‡è¯†åˆ«**: æ”¯æŒå›¾ç‰‡æ–‡ä»¶OCRè¯†åˆ«
- ğŸ§® **å…¬å¼è¯†åˆ«**: è‡ªåŠ¨è¯†åˆ«æ•°å­¦å…¬å¼å’ŒåŒ–å­¦å¼
- ğŸ“Š **è¡¨æ ¼è¯†åˆ«**: æ™ºèƒ½è¯†åˆ«è¡¨æ ¼ç»“æ„
- ğŸŒ **å¤šè¯­è¨€æ”¯æŒ**: æ”¯æŒä¸­æ–‡ã€è‹±æ–‡ç­‰å¤šç§è¯­è¨€

### ä½¿ç”¨æ­¥éª¤
1. **ä¸Šä¼ æ–‡ä»¶**: æ‹–æ‹½æˆ–ç‚¹å‡»é€‰æ‹©PDF/å›¾ç‰‡æ–‡ä»¶
2. **é…ç½®é€‰é¡¹**: è®¾ç½®è½¬æ¢å‚æ•°ï¼ˆé¡µæ•°ã€è¯­è¨€ç­‰ï¼‰
3. **å¼€å§‹è½¬æ¢**: ç‚¹å‡»"å¼€å§‹è½¬æ¢"æŒ‰é’®
4. **æŸ¥çœ‹ç»“æœ**: åœ¨å³ä¾§æŸ¥çœ‹è½¬æ¢åçš„Markdownå†…å®¹

---

<div style="text-align: center; margin: 40px 0;">
    <div style="display: inline-block; padding: 20px 30px; background: #f8f9fa; border: 2px dashed #dee2e6; border-radius: 12px;">
        <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“</div>
        <div style="color: #6c757d; font-size: 18px; font-weight: bold;">è¯·ä¸Šä¼ æ–‡ä»¶å¼€å§‹è½¬æ¢</div>
        <div style="color: #adb5bd; font-size: 14px; margin-top: 8px;">æ”¯æŒPDFå’Œå›¾ç‰‡æ–‡ä»¶</div>
    </div>
</div>`;

                document.getElementById('markdownPreview').innerHTML = 
                    `<div class="markdown-content">${this.markdownToHtml(defaultContent)}</div>`;
                document.getElementById('markdownText').textContent = defaultContent;
                
                // æ¸…ç©ºPDFé¢„è§ˆ
                this.clearPdfPreview();
            }

            switchTab(e) {
                const tabName = e.target.dataset.tab;
                this.switchToTab(tabName, e.target);
            }

            // ç‰ˆæœ¬å’ŒCHANGELOGç›¸å…³æ–¹æ³•
            showChangelog() {
                const modal = document.getElementById('changelogModal');
                const content = document.getElementById('changelogContent');
                
                // æ˜¾ç¤ºæ¨¡æ€æ¡†
                modal.style.display = 'block';
                
                // åŠ è½½CHANGELOGå†…å®¹
                this.loadChangelogContent(content);
            }

            closeChangelog() {
                const modal = document.getElementById('changelogModal');
                modal.style.display = 'none';
            }

            async loadChangelogContent(contentElement) {
                try {
                    const response = await fetch('/CHANGELOG.md');
                    if (response.ok) {
                        const markdown = await response.text();
                        // ç®€å•çš„Markdownåˆ°HTMLè½¬æ¢
                        const html = this.markdownToHtml(markdown);
                        contentElement.innerHTML = `<div class="changelog-content">${html}</div>`;
                    } else {
                        contentElement.innerHTML = '<div class="error">æ— æ³•åŠ è½½æ›´æ–°æ—¥å¿—</div>';
                    }
                } catch (error) {
                    console.error('åŠ è½½CHANGELOGå¤±è´¥:', error);
                    contentElement.innerHTML = '<div class="error">åŠ è½½æ›´æ–°æ—¥å¿—æ—¶å‡ºé”™</div>';
                }
            }

            markdownToHtml(markdown) {
                return markdown
                    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                    .replace(/^#### (.*$)/gim, '<h4>$1</h4>')
                    .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
                    .replace(/\*(.*)\*/gim, '<em>$1</em>')
                    .replace(/`(.*)`/gim, '<code>$1</code>')
                    .replace(/^- (.*$)/gim, '<li>$1</li>')
                    .replace(/^\[(.*)\]\((.*)\)/gim, '<a href="$2">$1</a>')
                    .replace(/\n\n/gim, '</p><p>')
                    .replace(/\n/gim, '<br>')
                    .replace(/^(<li>.*<\/li>)$/gim, '<ul>$1</ul>')
                    .replace(/<\/ul><ul>/gim, '')
                    .replace(/^(?!<[h|u|p|a|s|e|d])/gim, '<p>')
                    .replace(/(<li>.*<\/li><\/ul>)/gim, '<ul>$1</ul>');
            }
                
            switchToTab(tabName, targetElement = null) {
                // æ›´æ–°æ ‡ç­¾é¡µçŠ¶æ€
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                
                // å¦‚æœæä¾›äº†ç›®æ ‡å…ƒç´ ï¼Œæ¿€æ´»å®ƒï¼›å¦åˆ™æ‰¾åˆ°å¯¹åº”çš„æ ‡ç­¾é¡µ
                if (targetElement) {
                    targetElement.classList.add('active');
                } else {
                    const tabElement = document.querySelector(`[data-tab="${tabName}"]`);
                    if (tabElement) {
                        tabElement.classList.add('active');
                    }
                }
                
                // æ¿€æ´»å¯¹åº”çš„å†…å®¹åŒºåŸŸ
                const contentElement = document.getElementById(tabName + 'Tab');
                if (contentElement) {
                    contentElement.classList.add('active');
                }

                // å¦‚æœæ˜¯ç¤ºä¾‹æ ‡ç­¾é¡µï¼Œåˆ·æ–°åˆ—è¡¨
                if (tabName === 'examples') {
                    this.loadExamples();
                }
            }

            async loadExamples() {
                try {
                    const response = await fetch('/list_output_files');
                    const files = await response.json();
                    
                    const examplesList = document.getElementById('examplesList');
                    examplesList.innerHTML = '';

                    if (files.length === 0) {
                        examplesList.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">è¾“å‡ºç›®å½•ä¸ºç©º</p>';
                        return;
                    }

                    files.forEach(file => {
                        const exampleItem = document.createElement('div');
                        exampleItem.className = 'example-item';
                        exampleItem.innerHTML = `
                            <input type="checkbox" class="example-checkbox" data-filename="${file.name}">
                            <div class="example-name">${file.name}</div>
                            <div class="example-type">${file.type}</div>
                        `;
                        examplesList.appendChild(exampleItem);
                    });
                } catch (error) {
                    console.error('åŠ è½½è¾“å‡ºæ–‡ä»¶å¤±è´¥:', error);
                    document.getElementById('examplesList').innerHTML = 
                        '<p style="text-align: center; color: #f44336; padding: 20px;">åŠ è½½å¤±è´¥</p>';
                }
            }

            selectAllExamples() {
                const checkboxes = document.querySelectorAll('.example-checkbox');
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                
                checkboxes.forEach(cb => {
                    cb.checked = !allChecked;
                });
            }

            async deleteSelectedExamples() {
                const selectedFiles = Array.from(document.querySelectorAll('.example-checkbox:checked'))
                    .map(cb => cb.dataset.filename);

                if (selectedFiles.length === 0) {
                    alert('è¯·é€‰æ‹©è¦åˆ é™¤çš„æ–‡ä»¶');
                    return;
                }

                if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedFiles.length} ä¸ªæ–‡ä»¶å—ï¼Ÿ`)) {
                    return;
                }

                try {
                    const response = await fetch('/delete_output_files', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ files: selectedFiles })
                    });

                    if (response.ok) {
                        alert('åˆ é™¤æˆåŠŸ');
                        this.loadExamples();
                    } else {
                        throw new Error('åˆ é™¤å¤±è´¥');
                    }
                } catch (error) {
                    console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥:', error);
                    alert('åˆ é™¤å¤±è´¥: ' + error.message);
                }
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            markdownToHtml(markdown) {
                if (!markdown) return '';
                
                // ä½¿ç”¨marked.jsè¿›è¡ŒMarkdownæ¸²æŸ“
                if (typeof marked !== 'undefined') {
                    // é…ç½®markedé€‰é¡¹
                    marked.setOptions({
                        breaks: true,
                        gfm: true,
                        tables: true,
                        sanitize: false
                    });
                    
                    let html = marked.parse(markdown);
                    
                    // æ¸²æŸ“æ•°å­¦å…¬å¼
                    this.renderMath(html);
                    
                    return html;
                } else {
                    // é™çº§åˆ°ç®€å•çš„Markdownæ¸²æŸ“
                    return this.simpleMarkdownToHtml(markdown);
                }
            }
            
            renderMath(html) {
                // å»¶è¿Ÿæ¸²æŸ“æ•°å­¦å…¬å¼ï¼Œç¡®ä¿DOMå·²æ›´æ–°
                setTimeout(() => {
                    if (typeof renderMathInElement !== 'undefined') {
                        const element = document.getElementById('markdownPreview');
                        if (element) {
                            renderMathInElement(element, {
                                delimiters: [
                                    {left: '$$', right: '$$', display: true},
                                    {left: '$', right: '$', display: false},
                                    {left: '\\(', right: '\\)', display: false},
                                    {left: '\\[', right: '\\]', display: true}
                                ],
                                throwOnError: false
                            });
                        }
                    }
                }, 100);
            }
            
            simpleMarkdownToHtml(markdown) {
                // ç®€å•çš„Markdownæ¸²æŸ“ä½œä¸ºé™çº§æ–¹æ¡ˆ
                let html = markdown;
                
                // å¤„ç†ä»£ç å—
                html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
                html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // å¤„ç†æ ‡é¢˜
                html = html.replace(/^#{6}\s+(.*)$/gm, '<h6>$1</h6>');
                html = html.replace(/^#{5}\s+(.*)$/gm, '<h5>$1</h5>');
                html = html.replace(/^#{4}\s+(.*)$/gm, '<h4>$1</h4>');
                html = html.replace(/^#{3}\s+(.*)$/gm, '<h3>$1</h3>');
                html = html.replace(/^#{2}\s+(.*)$/gm, '<h2>$1</h2>');
                html = html.replace(/^#{1}\s+(.*)$/gm, '<h1>$1</h1>');
                
                // å¤„ç†å…¶ä»–æ ¼å¼
                html = html.replace(/^[-*]{3,}$/gm, '<hr>');
                html = html.replace(/^>\s+(.*)$/gm, '<blockquote>$1</blockquote>');
                html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width: 100%; height: auto;">');
                html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
                html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                html = html.replace(/__(.*?)__/g, '<strong>$1</strong>');
                html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
                html = html.replace(/_(.*?)_/g, '<em>$1</em>');
                html = html.replace(/~~(.*?)~~/g, '<del>$1</del>');
                
                return html;
            }
            
            // å¤åˆ¶åŠŸèƒ½
            copyMarkdown() {
                const markdownPreview = document.getElementById('markdownPreview');
                if (markdownPreview) {
                    // å¤åˆ¶æ¸²æŸ“åçš„HTMLå†…å®¹
                    const htmlContent = markdownPreview.innerHTML;
                    this.copyToClipboard(htmlContent);
                    this.showCopySuccess('copyMarkdownBtn');
                }
            }
            
            copyText() {
                const markdownText = document.getElementById('markdownText');
                if (markdownText && markdownText.textContent) {
                    this.copyToClipboard(markdownText.textContent);
                    this.showCopySuccess('copyTextBtn');
                }
            }
            
            copyToClipboard(text) {
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text).then(() => {
                        console.log('å¤åˆ¶æˆåŠŸ');
                    }).catch(err => {
                        console.error('å¤åˆ¶å¤±è´¥:', err);
                        this.fallbackCopyToClipboard(text);
                    });
                } else {
                    this.fallbackCopyToClipboard(text);
                }
            }
            
            fallbackCopyToClipboard(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    console.log('å¤åˆ¶æˆåŠŸ');
                } catch (err) {
                    console.error('å¤åˆ¶å¤±è´¥:', err);
                }
                
                document.body.removeChild(textArea);
            }
            
            showCopySuccess(buttonId) {
                const button = document.getElementById(buttonId);
                const originalText = button.textContent;
                button.textContent = 'âœ… å·²å¤åˆ¶';
                button.style.background = '#28a745';
                button.style.color = 'white';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '#f6f8fa';
                    button.style.color = '#586069';
                }, 2000);
            }

            showPdfPreview(file) {
                const pdfPreviewContainer = document.getElementById('pdfPreviewContainer');
                if (!file) {
                    this.clearPdfPreview();
                    return;
                }

                // ä»…åœ¨æä¾›çš„æ˜¯Blob/Fileæ—¶é¢„è§ˆ
                if (!(file instanceof Blob)) {
                    // åˆ·æ–°åæœ¬åœ°æ— Blobæ—¶ç»™å‡ºå‹å¥½æç¤º
                    pdfPreviewContainer.innerHTML = `
                        <div class="pdf-preview-placeholder">
                            <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“„</div>
                            <p>æ— æ³•æ˜¾ç¤ºPDFé¢„è§ˆ</p>
                            <p style="font-size: 14px; color: #999;">åˆ·æ–°åæ— æ³•æ¢å¤æ–‡ä»¶æ•°æ®ï¼Œè¯·é‡æ–°ä¸Šä¼  PDF ä»¥æŸ¥çœ‹é¢„è§ˆ</p>
                        </div>
                    `;
                    return;
                }

                const url = URL.createObjectURL(file);
                pdfPreviewContainer.innerHTML = `
                    <iframe src="${url}" 
                            class="pdf-preview-iframe"
                            title="PDFé¢„è§ˆ">
                    </iframe>
                `;
            }

            showPdfPreviewByUrl(url) {
                const pdfPreviewContainer = document.getElementById('pdfPreviewContainer');
                if (!url) {
                    this.clearPdfPreview();
                    return;
                }
                pdfPreviewContainer.innerHTML = `
                    <iframe src="${url}" 
                            class="pdf-preview-iframe"
                            title="PDFé¢„è§ˆ">
                    </iframe>
                `;
            }

            clearPdfPreview() {
                const pdfPreviewContainer = document.getElementById('pdfPreviewContainer');
                pdfPreviewContainer.innerHTML = `
                    <div class="pdf-preview-placeholder">
                        <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“„</div>
                        <p>PDFé¢„è§ˆ</p>
                        <p style="font-size: 14px; color: #999;">ä¸Šä¼ PDFæ–‡ä»¶åå°†æ˜¾ç¤ºé¢„è§ˆ</p>
                    </div>
                `;
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        const app = new MinerUApp();
    </script>
</body>
</html>
